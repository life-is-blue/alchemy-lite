# ============================================================================
# CI/CD Configuration - Linus Style
# ============================================================================
# Philosophy:
#   1. Don't break userspace (production).
#   2. Every release is a Git tag. No magic timestamps.
#   3. Build and Deploy are SEPARATED. Build on tag, deploy manually.
#   4. You MUST be able to rollback. Always.
#   5. Keep it simple, stupid.
# ============================================================================

# ============================================================================
# Branch Push: Build and Test Only - DO NOT DEPLOY
# ============================================================================
# Every push to main triggers CI, but does NOT touch production.
# This is a sanity check. If tests fail, fix your damn code.
# ============================================================================

main:
  push:
    - services:
        - docker
      docker:
        image: node:20
        volumes:
          - /root/.npm:cow
          - ./node_modules
      stages:
        - name: test-and-build
          script: |
            set -eu
            echo "==> Running tests. If this fails, don't even think about releasing."
            npm ci
            npm test
            npm run build
            echo "==> Tests passed. Build artifacts ready."
        
        - name: build-dev-image
          image: docker:24-cli
          script: |
            set -eu
            DEV_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:dev-$(date +%Y%m%d-%H%M%S)"
            
            echo "==> Building dev image: ${DEV_TAG}"
            echo "${CNB_TOKEN}" | docker login -u "${CNB_TOKEN_USER_NAME}" --password-stdin "${CNB_DOCKER_REGISTRY}"
            docker build -t "${DEV_TAG}" .
            docker push "${DEV_TAG}"
            echo "==> Dev image pushed. Use this for staging/testing, NOT production."

# ============================================================================
# Tag Push: Build Release Image ONLY - DO NOT AUTO-DEPLOY
# ============================================================================
# When ready to release, tag it: git tag v1.2.3 && git push origin v1.2.3
# This builds and pushes the Docker image to registry.
# To deploy to production, use manual 'deploy' operation (see below).
#
# Pattern: "v*.*.*" matches semantic version tags like v1.2.3, v2.0.0, etc.
# ============================================================================

"v*.*.*":
  tag_push:
    - services:
        - docker
      docker:
        image: node:20
        volumes:
          - /root/.npm:cow
          - ./node_modules
      stages:
        - name: test-and-build
          script: |
            set -eu
            VERSION="${CNB_BRANCH}"
            if [ -z "${VERSION}" ]; then
              echo "==> FATAL: CNB_BRANCH is not set. This should never happen."
              exit 1
            fi
            echo "==> Building release ${VERSION}"
            npm ci
            npm test
            npm run build
            echo "==> Release build complete."
        
        - name: build-and-push-release
          image: docker:24-cli
          script: |
            set -eu
            VERSION="${CNB_BRANCH}"
            if [ -z "${VERSION}" ]; then
              echo "==> FATAL: CNB_BRANCH is not set. This should never happen."
              exit 1
            fi
            
            IMAGE_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:${VERSION}"
            LATEST_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:latest"
            
            echo "==> Building production image for version ${VERSION}" >&2
            echo "${CNB_TOKEN}" | docker login -u "${CNB_TOKEN_USER_NAME}" --password-stdin "${CNB_DOCKER_REGISTRY}" >&2
            docker pull "${LATEST_TAG}" >&2 || true
            export DOCKER_BUILDKIT=1
            docker build --cache-from "${LATEST_TAG}" -t "${IMAGE_TAG}" . >&2
            docker tag "${IMAGE_TAG}" "${LATEST_TAG}" >&2
            docker push "${IMAGE_TAG}" >&2
            docker push "${LATEST_TAG}" >&2
            echo "==> Pushed: ${IMAGE_TAG}" >&2
            echo "==> Pushed: ${LATEST_TAG}" >&2
            echo "==> Build complete. To deploy, run manual 'deploy' with DEPLOY_VERSION=${VERSION}" >&2

# ============================================================================
# Manual Operations
# ============================================================================

$:
  # -------------------------------------------------------------------------
  # Manual Deploy to Production
  # -------------------------------------------------------------------------
  # Usage: Trigger this manually in CI, set DEPLOY_VERSION env var.
  # Example: DEPLOY_VERSION=v1.2.3
  # This deploys a previously built image to production.
  # -------------------------------------------------------------------------
  deploy:
    - services:
        - docker
      stages:
        - name: deploy-to-production
          image: cnbcool/ssh
          imports: https://cnb.cool/ai-alchemy-factory/project-secrets/-/blob/main/firecrawl-lite-ssh.yml
          settings:
            host:
              - ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 5m
            script: |
              VERSION="${DEPLOY_VERSION:-}"
              if [ -z "${VERSION}" ]; then
                echo "==> ERROR: DEPLOY_VERSION environment variable not set."
                echo "==> Usage: trigger this manually and set DEPLOY_VERSION=v1.2.3"
                exit 1
              fi
              
              IMAGE="docker.cnb.cool/ai-alchemy-factory/firecrawl-lite:${VERSION}"
              
              echo "==> Deploying version ${VERSION}"
              
              # Login to registry
              echo "${REGISTRY_TOKEN}" | docker login -u "${REGISTRY_USER}" --password-stdin docker.cnb.cool
              docker pull "${IMAGE}"
              
              # ============================================================
              # Step 0: Create Docker network
              # ============================================================
              docker network create firecrawl-network || true
              
              # ============================================================
              # Step 1: Deploy Backend API (internal port 3000)
              # ============================================================
              echo "==> Deploying backend API..."
              docker stop firecrawl-lite-backend || true
              docker rm firecrawl-lite-backend || true
              
              docker run -d \
                --name firecrawl-lite-backend \
                --network firecrawl-network \
                --restart=always \
                -e VERSION="${VERSION}" \
                "${IMAGE}"
              
              # ============================================================
              # Step 2: Deploy Frontend (static files)
              # ============================================================
              echo "==> Deploying frontend..."
              
              # Fetch frontend files from repo (Dockerfile doesn't include public/)
              rm -rf /tmp/firecrawl-frontend /tmp/firecrawl-repo
              
              if ! git clone --depth 1 --branch "${VERSION}" \
                https://github.com/ai-alchemy-factory/firecrawl-lite /tmp/firecrawl-repo; then
                echo "==> ERROR: Failed to fetch frontend for version ${VERSION}"
                echo "==> Make sure the tag exists and the repo is accessible"
                exit 1
              fi
              
              if [ ! -d "/tmp/firecrawl-repo/public" ]; then
                echo "==> ERROR: public/ directory not found in repo"
                rm -rf /tmp/firecrawl-repo
                exit 1
              fi
              
              cp -r /tmp/firecrawl-repo/public /tmp/firecrawl-frontend
              rm -rf /tmp/firecrawl-repo
              
              docker stop firecrawl-lite-frontend || true
              docker rm firecrawl-lite-frontend || true
              
              docker run -d \
                --name firecrawl-lite-frontend \
                --network firecrawl-network \
                --restart=always \
                -v /tmp/firecrawl-frontend:/usr/share/nginx/html:ro \
                nginx:alpine
              
              # ============================================================
              # Step 3: Deploy Reverse Proxy (Caddy on port 80)
              # ============================================================
              echo "==> Deploying reverse proxy..."
              
              # Create Caddyfile
              cat > /tmp/Caddyfile <<'CADDY'
              :80 {
                # API backend
                route /api* {
                  reverse_proxy firecrawl-lite-backend:3000
                }
                
                # Frontend
                route /* {
                  reverse_proxy firecrawl-lite-frontend:80
                }
              }
              CADDY
              
              docker stop firecrawl-lite-proxy || true
              docker rm firecrawl-lite-proxy || true
              
              docker run -d -p 80:80 \
                --name firecrawl-lite-proxy \
                --network firecrawl-network \
                --restart=always \
                -v /tmp/Caddyfile:/etc/caddy/Caddyfile:ro \
                caddy:latest
              
              # ============================================================
              # Step 4: Verify deployment with health checks
              # ============================================================
              echo "==> Verifying deployment..."
              sleep 3
              
              # Check backend health
              if ! docker exec firecrawl-lite-backend wget -q -O- http://localhost:3000/api/health > /dev/null; then
                echo "==> ERROR: Backend health check failed"
                docker logs --tail 20 firecrawl-lite-backend
                exit 1
              fi
              
              # Check frontend (Nginx serves on port 80)
              if ! docker exec firecrawl-lite-frontend wget -q -O- http://localhost:80 > /dev/null; then
                echo "==> ERROR: Frontend health check failed"
                docker logs --tail 20 firecrawl-lite-frontend
                exit 1
              fi
              
              # Check proxy (accessible from host)
              if ! wget -q -O- http://localhost:80 > /dev/null; then
                echo "==> ERROR: Proxy health check failed"
                docker logs --tail 20 firecrawl-lite-proxy
                exit 1
              fi
              
              echo "==> All health checks passed âœ“"
              echo "==> Deployment complete"
              echo "==> Access your app at: http://localhost:80"
              echo "==> (Backend and frontend are internal, only proxy is exposed)"
              docker ps | grep firecrawl-lite
  
  # -------------------------------------------------------------------------
  # Manual Rollback to Specific Version
  # -------------------------------------------------------------------------
  # Usage: Trigger this manually in CI, set ROLLBACK_VERSION env var.
  # Example: ROLLBACK_VERSION=v1.2.2
  # Same as deploy, just semantically different name.
  # -------------------------------------------------------------------------
  rollback:
    - services:
        - docker
      stages:
        - name: rollback-to-version
          image: cnbcool/ssh
          imports: https://cnb.cool/ai-alchemy-factory/project-secrets/-/blob/main/firecrawl-lite-ssh.yml
          settings:
            host:
              - ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 5m
            script: |
              TARGET_VERSION="${ROLLBACK_VERSION:-}"
              if [ -z "${TARGET_VERSION}" ]; then
                echo "==> ERROR: ROLLBACK_VERSION environment variable not set."
                echo "==> Usage: trigger this manually and set ROLLBACK_VERSION=v1.2.2"
                exit 1
              fi
              
              IMAGE="docker.cnb.cool/ai-alchemy-factory/firecrawl-lite:${TARGET_VERSION}"
              
              echo "==> Rolling back to version ${TARGET_VERSION}"
              
              echo "${REGISTRY_TOKEN}" | docker login -u "${REGISTRY_USER}" --password-stdin docker.cnb.cool
              docker pull "${IMAGE}"
              
              # Rollback backend only (frontend and proxy unchanged)
              docker stop firecrawl-lite-backend || true
              docker rm firecrawl-lite-backend || true
              
              docker run -d \
                --name firecrawl-lite-backend \
                --network firecrawl-network \
                --restart=always \
                -e VERSION="${TARGET_VERSION}" \
                "${IMAGE}"
              
              echo "==> Rollback complete (backend only)"
              docker ps | grep firecrawl-lite
  
  # -------------------------------------------------------------------------
  # Check Current Production Version
  # -------------------------------------------------------------------------
  check-version:
    - services:
        - docker
      stages:
        - name: show-current-version
          image: cnbcool/ssh
          imports: https://cnb.cool/ai-alchemy-factory/project-secrets/-/blob/main/firecrawl-lite-ssh.yml
          settings:
            host:
              - ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 1m
            script: |
              echo "==> Running container:"
              docker ps --filter name=firecrawl-lite --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
