# ============================================================================
# CI/CD Configuration - Linus Style
# ============================================================================
# Philosophy:
#   1. Don't break userspace (production).
#   2. Every release is a Git tag. No magic timestamps.
#   3. Build and Deploy are SEPARATED. Build on tag, deploy manually.
#   4. You MUST be able to rollback. Always.
#   5. Keep it simple, stupid.
#
# Parameter Management:
#   - Build stage: Zero env dependencies (pure compilation)
#   - Deploy stage: All secrets via imports (not from .env)
#   - No over-parameterization: Only essential variables
#
# How to Deploy (Manual):
#   1. Tag a release: git tag v1.2.3 && git push origin v1.2.3
#   2. CI builds and pushes Docker image
#   3. Manually trigger deploy in CNB with DEPLOY_VERSION=v1.2.3
# ============================================================================

# ============================================================================
# Branch Push: Build and Test Only - DO NOT DEPLOY
# ============================================================================
# Every push to main triggers CI, but does NOT touch production.
# This is a sanity check. If tests fail, fix your damn code.
# ============================================================================

main:
  push:
    - services:
        - docker
      docker:
        image: node:20
        volumes:
          - /root/.npm:cow
          - ./node_modules
      stages:
        - name: test-and-build
          script: |
            set -eu
            echo "==> Running tests. If this fails, don't even think about releasing."
            npm ci
            npm test
            npm run build
            echo "==> Tests passed. Build artifacts ready."
        
        - name: build-dev-image
          image: docker:24-cli
          script: |
            set -eu
            DEV_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:dev-$(date +%Y%m%d-%H%M%S)"
            
            echo "==> Building dev image: ${DEV_TAG}"
            echo "${CNB_TOKEN}" | docker login -u "${CNB_TOKEN_USER_NAME}" --password-stdin "${CNB_DOCKER_REGISTRY}"
            docker build -t "${DEV_TAG}" .
            docker push "${DEV_TAG}"
            echo "==> Dev image pushed. Use this for staging/testing, NOT production."

# ============================================================================
# Tag Push: Build Release Image & Auto-Deploy
# ============================================================================
# When ready to release, tag it: git tag v1.2.3 && git push origin v1.2.3
# This automatically:
#   1. Builds and tests the code
#   2. Pushes Docker image to registry
#   3. Deploys to production
#
# Pattern: "v*.*.*" matches semantic version tags like v1.2.3, v2.0.0, etc.
# ============================================================================

"v*.*.*":
  tag_push:
    - services:
        - docker
      docker:
        image: node:20
        volumes:
          - /root/.npm:cow
          - ./node_modules
      stages:
        - name: test-and-build
          script: |
            set -eu
            VERSION="${CNB_BRANCH}"
            if [ -z "${VERSION}" ]; then
              echo "==> FATAL: CNB_BRANCH is not set. This should never happen."
              exit 1
            fi
            echo "==> Building release ${VERSION}"
            npm ci
            npm test
            npm run build
            echo "==> Release build complete."
            # Write version to file for reliable cross-stage passing (avoids stdout export issues)
            printf "%s" "${VERSION}" > /tmp/release-version.txt
        
        - name: build-and-push-release
          image: docker:24-cli
          script: |
            set -eu
            # Read version from file written by previous stage
            if [ ! -f /tmp/release-version.txt ]; then
              echo "==> FATAL: /tmp/release-version.txt not found. Previous stage may have failed."
              exit 1
            fi
            VERSION=$(cat /tmp/release-version.txt)
            if [ -z "${VERSION}" ]; then
              echo "==> FATAL: Version file is empty."
              exit 1
            fi
            
            IMAGE_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:${VERSION}"
            LATEST_TAG="${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:latest"
            
            echo "==> Building production image for version ${VERSION}" >&2
            echo "${CNB_TOKEN}" | docker login -u "${CNB_TOKEN_USER_NAME}" --password-stdin "${CNB_DOCKER_REGISTRY}" >&2
            docker pull "${LATEST_TAG}" >&2 || true
            export DOCKER_BUILDKIT=1
            docker build --cache-from "${LATEST_TAG}" -t "${IMAGE_TAG}" . >&2
            docker tag "${IMAGE_TAG}" "${LATEST_TAG}" >&2
            docker push "${IMAGE_TAG}" >&2
            docker push "${LATEST_TAG}" >&2
            echo "==> Pushed: ${IMAGE_TAG}" >&2
            echo "==> Pushed: ${LATEST_TAG}" >&2
            echo "==> Build complete. Auto-deploying to production..." >&2
        
        - name: auto-deploy-to-production
          image: cnbcool/ssh
          imports: https://cnb.cool/ai-alchemy-factory/project-secrets/-/blob/main/firecrawl-lite-ssh.yml
          settings:
            host: ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 5m
            script: |
              # Read version from file written by test-and-build stage
              if [ ! -f /tmp/release-version.txt ]; then
                echo "==> FATAL: /tmp/release-version.txt not found."
                exit 1
              fi
              VERSION=$(cat /tmp/release-version.txt)
              if [ -z "${VERSION}" ]; then
                echo "==> ERROR: Version file is empty."
                exit 1
              fi
              
              IMAGE="docker.cnb.cool/ai-alchemy-factory/firecrawl-lite:${VERSION}"
              
              echo "==> Deploying version ${VERSION}"
              
              # Login to registry
              echo "${REGISTRY_TOKEN}" | docker login -u "${REGISTRY_USER}" --password-stdin docker.cnb.cool
              docker pull "${IMAGE}"
              
              # ============================================================
              # Deploy Single Container (Backend + Caddy + Frontend)
              # ============================================================
              echo "==> Deploying Firecrawl Lite (single container with HTTPS)"
              
              # Create persistent volume for SSL certificates (secure permissions)
              mkdir -p /opt/firecrawl-lite/caddy-data
              chmod 700 /opt/firecrawl-lite/caddy-data
              
              # Stop and remove old container(s)
              docker stop firecrawl-lite 2>/dev/null || true
              docker rm firecrawl-lite 2>/dev/null || true
              
              # Also clean up old 3-container architecture if exists
              docker stop firecrawl-lite-backend firecrawl-lite-frontend firecrawl-lite-proxy 2>/dev/null || true
              docker rm firecrawl-lite-backend firecrawl-lite-frontend firecrawl-lite-proxy 2>/dev/null || true
              docker network rm firecrawl-network 2>/dev/null || true
              
              # Deploy single container
              docker run -d \
                -p 80:80 \
                -p 443:443 \
                --name firecrawl-lite \
                --restart=always \
                -v /opt/firecrawl-lite/caddy-data:/data \
                -e VERSION="${VERSION}" \
                "${IMAGE}"
              
              # ============================================================
              # Verify deployment with health checks
              # ============================================================
              echo "==> Waiting for container to start..."
              sleep 5
              
              # Check if container is running
              if ! docker ps | grep -q firecrawl-lite; then
                echo "==> ERROR: Container failed to start"
                docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              # Wait for backend to be ready (max 10 seconds)
              echo "==> Waiting for backend to be ready..."
              for i in $(seq 1 10); do
                if docker exec firecrawl-lite curl -sf http://localhost:3000/api/health >/dev/null 2>&1; then
                  echo "==> Backend is ready"
                  break
                fi
                sleep 1
              done
              
              # Check backend health
              if ! docker exec firecrawl-lite curl -sf http://localhost:3000/api/health >/dev/null 2>&1; then
                echo "==> ERROR: Backend health check failed"
                docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              # Wait for Caddy to start and test HTTPS (with retry)
              echo "==> Waiting for Caddy to start and obtain SSL certificate..."
              sleep 5
              
              # Try HTTPS for up to 60 seconds (Let's Encrypt can be slow)
              HTTPS_OK=false
              for i in $(seq 1 12); do
                if curl -f --max-time 5 https://${DOMAIN:-your-domain.com}/api/health >/dev/null 2>&1; then
                  echo "==> ✓ HTTPS is working (SSL certificate obtained)"
                  HTTPS_OK=true
                  break
                fi
                echo "==> Attempt $i/12: HTTPS not ready yet..."
                sleep 5
              done
              
              # If HTTPS failed, check logs and exit
              if [ "$HTTPS_OK" = false ]; then
                echo "==> ✗ ERROR: HTTPS failed after 60 seconds"
                echo "==> This usually means:"
                echo "    1. DNS not pointing to this server (check: dig ${DOMAIN:-your-domain.com})"
                echo "    2. Ports 80/443 not accessible (check firewall)"
                echo "    3. Let's Encrypt rate limit hit"
                echo ""
                echo "==> Container logs (last 50 lines):"
                docker logs --tail 50 firecrawl-lite | grep -i "acme\|certificate\|error" || docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              echo "==> ✓ Deployment complete"
              echo "==> Container status:"
              docker ps | grep firecrawl-lite
              echo ""
              echo "==> Access your app at:"
              echo "    https://${DOMAIN:-your-domain.com}/ (HTTPS - recommended)"
              echo "    http://${DOMAIN:-your-domain.com}/  (HTTP - redirects to HTTPS)"
              echo ""
              echo "==> Check SSL certificate:"
              echo "    docker logs firecrawl-lite | grep -i certificate"

# ============================================================================
# Manual Operations
# ============================================================================
#
# Deployment Parameter Management:
#   - All secrets (SSH keys, registry tokens) are imported via `imports`
#   - The imports file (firecrawl-lite-ssh.yml) is stored in project-secrets
#   - Variables provided by imports:
#       * ${REMOTE_HOST}       - Target server IP/hostname
#       * ${REMOTE_USERNAME}   - SSH user (usually root)
#       * ${REMOTE_PORT}       - SSH port (default 22)
#       * ${PRIVATE_KEY}       - SSH private key (for authentication)
#       * ${REGISTRY_TOKEN}    - Docker registry auth token
#       * ${REGISTRY_USER}     - Docker registry username
#
# To set up:
#   1. Create firecrawl-lite-ssh.yml in project-secrets
#   2. Define the environment variables above in that file
#   3. Set DEPLOY_SECRETS_IMPORTS variable to point to that file
# ============================================================================

$:
  # -------------------------------------------------------------------------
  # Manual Deploy to Production (Emergency/Specific Version)
  # -------------------------------------------------------------------------
  # NOTE: Normally deployments happen automatically when you push a tag.
  #       Use this only for emergency rollback or deploying a specific version.
  #
  # How it works:
  #   1. Requires explicit DEPLOY_VERSION environment variable
  #   2. Pulls specified Docker image from registry
  #   3. Deploys to production server with health checks
  #
  # Trigger manually with:
  #   Set DEPLOY_VERSION=v1.2.3 environment variable, then run this operation
  #
  # Parameters from imports (auto-loaded):
  #   ${REMOTE_HOST}, ${REMOTE_USERNAME}, ${PRIVATE_KEY}, ${REMOTE_PORT}
  #   ${REGISTRY_TOKEN}, ${REGISTRY_USER}, ${DOMAIN}
  # -------------------------------------------------------------------------
  deploy:
    - services:
        - docker
      stages:
        - name: deploy-to-production
          image: cnbcool/ssh
          imports: https://cnb.cool/ai-alchemy-factory/project-secrets/-/blob/main/firecrawl-lite-ssh.yml
          settings:
            host: ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 5m
            script: |
              VERSION="${DEPLOY_VERSION:-}"
              if [ -z "${VERSION}" ]; then
                echo "==> ERROR: DEPLOY_VERSION environment variable not set."
                echo "==> Usage: trigger this manually and set DEPLOY_VERSION=v1.2.3"
                exit 1
              fi
              
              IMAGE="docker.cnb.cool/ai-alchemy-factory/firecrawl-lite:${VERSION}"
              
              echo "==> Deploying version ${VERSION}"
              
              # Login to registry
              echo "${REGISTRY_TOKEN}" | docker login -u "${REGISTRY_USER}" --password-stdin docker.cnb.cool
              docker pull "${IMAGE}"
              
              # ============================================================
              # Deploy Single Container (Backend + Caddy + Frontend)
              # ============================================================
              echo "==> Deploying Firecrawl Lite (single container with HTTPS)"
              
              # Create persistent volume for SSL certificates (secure permissions)
              mkdir -p /opt/firecrawl-lite/caddy-data
              chmod 700 /opt/firecrawl-lite/caddy-data
              
              # Stop and remove old container(s)
              docker stop firecrawl-lite 2>/dev/null || true
              docker rm firecrawl-lite 2>/dev/null || true
              
              # Also clean up old 3-container architecture if exists
              docker stop firecrawl-lite-backend firecrawl-lite-frontend firecrawl-lite-proxy 2>/dev/null || true
              docker rm firecrawl-lite-backend firecrawl-lite-frontend firecrawl-lite-proxy 2>/dev/null || true
              docker network rm firecrawl-network 2>/dev/null || true
              
              # Deploy single container
              docker run -d \
                -p 80:80 \
                -p 443:443 \
                --name firecrawl-lite \
                --restart=always \
                -v /opt/firecrawl-lite/caddy-data:/data \
                -e VERSION="${VERSION}" \
                "${IMAGE}"
              
              # ============================================================
              # Verify deployment with health checks
              # ============================================================
              echo "==> Waiting for container to start..."
              sleep 5
              
              # Check if container is running
              if ! docker ps | grep -q firecrawl-lite; then
                echo "==> ERROR: Container failed to start"
                docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              # Wait for backend to be ready (max 10 seconds)
              echo "==> Waiting for backend to be ready..."
              for i in $(seq 1 10); do
                if docker exec firecrawl-lite curl -sf http://localhost:3000/api/health >/dev/null 2>&1; then
                  echo "==> Backend is ready"
                  break
                fi
                sleep 1
              done
              
              # Check backend health
              if ! docker exec firecrawl-lite curl -sf http://localhost:3000/api/health >/dev/null 2>&1; then
                echo "==> ERROR: Backend health check failed"
                docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              # Wait for Caddy to start and test HTTPS (with retry)
              echo "==> Waiting for Caddy to start and obtain SSL certificate..."
              sleep 5
              
              # Try HTTPS for up to 60 seconds (Let's Encrypt can be slow)
              HTTPS_OK=false
              for i in $(seq 1 12); do
                if curl -f --max-time 5 https://${DOMAIN:-your-domain.com}/api/health >/dev/null 2>&1; then
                  echo "==> ✓ HTTPS is working (SSL certificate obtained)"
                  HTTPS_OK=true
                  break
                fi
                echo "==> Attempt $i/12: HTTPS not ready yet..."
                sleep 5
              done
              
              # If HTTPS failed, check logs and exit
              if [ "$HTTPS_OK" = false ]; then
                echo "==> ✗ ERROR: HTTPS failed after 60 seconds"
                echo "==> This usually means:"
                echo "    1. DNS not pointing to this server (check: dig ${DOMAIN:-your-domain.com})"
                echo "    2. Ports 80/443 not accessible (check firewall)"
                echo "    3. Let's Encrypt rate limit hit"
                echo ""
                echo "==> Container logs (last 50 lines):"
                docker logs --tail 50 firecrawl-lite | grep -i "acme\|certificate\|error" || docker logs --tail 50 firecrawl-lite
                exit 1
              fi
              
              echo "==> ✓ Deployment complete"
              echo "==> Container status:"
              docker ps | grep firecrawl-lite
              echo ""
              echo "==> Access your app at:"
              echo "    https://${DOMAIN:-your-domain.com}/ (HTTPS - recommended)"
              echo "    http://${DOMAIN:-your-domain.com}/  (HTTP - redirects to HTTPS)"
              echo ""
              echo "==> Check SSL certificate:"
              echo "    docker logs firecrawl-lite | grep -i certificate"
  
  # -------------------------------------------------------------------------
  # Manual Rollback to Specific Version
  # -------------------------------------------------------------------------
  # Usage: Trigger this manually in CI, set ROLLBACK_VERSION env var.
  # Example: ROLLBACK_VERSION=v1.2.2
  # Same as deploy, just semantically different name.
  # -------------------------------------------------------------------------
  rollback:
    - services:
        - docker
      stages:
        - name: rollback-to-version
          image: cnbcool/ssh
          imports: ${DEPLOY_SECRETS_IMPORTS}
          settings:
            host: ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 5m
            script: |
              TARGET_VERSION="${ROLLBACK_VERSION:-}"
              if [ -z "${TARGET_VERSION}" ]; then
                echo "==> ERROR: ROLLBACK_VERSION environment variable not set."
                echo "==> Usage: trigger this manually and set ROLLBACK_VERSION=v1.2.2"
                exit 1
              fi
              
              IMAGE="docker.cnb.cool/ai-alchemy-factory/firecrawl-lite:${TARGET_VERSION}"
              
              echo "==> Rolling back to version ${TARGET_VERSION}"
              
              echo "${REGISTRY_TOKEN}" | docker login -u "${REGISTRY_USER}" --password-stdin docker.cnb.cool
              docker pull "${IMAGE}"
              
              # Rollback entire container
              echo "==> Stopping current container..."
              docker stop firecrawl-lite || true
              docker rm firecrawl-lite || true
              
              echo "==> Starting rollback version ${TARGET_VERSION}..."
              docker run -d \
                -p 80:80 \
                -p 443:443 \
                --name firecrawl-lite \
                --restart=always \
                -v /opt/firecrawl-lite/caddy-data:/data \
                -e VERSION="${TARGET_VERSION}" \
                "${IMAGE}"
              
              # Wait for startup
              sleep 10
              
              # Verify rollback
              if docker exec firecrawl-lite curl -sf http://localhost:3000/api/health >/dev/null 2>&1; then
                echo "==> ✓ Rollback complete"
                docker ps | grep firecrawl-lite
              else
                echo "==> ERROR: Rollback failed - container not healthy"
                docker logs --tail 50 firecrawl-lite
                exit 1
              fi
  
  # -------------------------------------------------------------------------
  # Check Current Production Version
  # -------------------------------------------------------------------------
  check-version:
    - services:
        - docker
      stages:
        - name: show-current-version
          image: cnbcool/ssh
          imports: ${DEPLOY_SECRETS_IMPORTS}
          settings:
            host: ${REMOTE_HOST}
            username: ${REMOTE_USERNAME}
            key: ${PRIVATE_KEY}
            port: ${REMOTE_PORT}
            command_timeout: 1m
            script: |
              echo "==> Running container:"
              docker ps --filter name=firecrawl-lite --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
